// /**
//  * Jaqpot API
//  * Jaqpot v4 (Quattro) is the 4th version of a YAQP, a RESTful web service which can be used to train machine learning models and use them to obtain toxicological predictions for given chemical compounds or engineered nano materials. The project is written in Java8 and JEE7.
//  *
//  * OpenAPI spec version: 4.0.3
//  * Contact: hampos@me.com
//  *
//  * NOTE: This class is auto generated by the swagger code generator program.
//  * https://github.com/swagger-api/swagger-codegen.git
//  * Do not edit the class manually.
//  */

// /* tslint:disable:no-unused-variable member-ordering */

// import { Inject, Injectable, Optional }                      from '@angular/core';
// import { Http, Headers, URLSearchParams }                    from '@angular/http';
// import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
// import { Response, ResponseContentType }                     from '@angular/http';

// import { Observable }                                        from 'rxjs/Observable';
// import '../rxjs-operators';

// import { BibTeX } from '../model/bibTeX';
// import { ErrorReport } from '../model/errorReport';

// import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
// import { Configuration }                                     from '../configuration';

// @Injectable()
// export class BibtexService {

//     protected basePath = 'http://dev.jaqpot.org:8081/jaqpot/services';
//     public defaultHeaders: Headers = new Headers();
//     public configuration: Configuration = new Configuration();

//     constructor(protected http: Http, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
//         if (basePath) {
//             this.basePath = basePath;
//         }
//         if (configuration) {
//             this.configuration = configuration;
// 			this.basePath = basePath || configuration.basePath || this.basePath;
//         }
//     }

//     /**
//      *
//      * Extends object by coping non-existing properties.
//      * @param objA object to be extended
//      * @param objB source object
//      */
//     private extendObj<T1,T2>(objA: T1, objB: T2) {
//         for(let key in objB){
//             if(objB.hasOwnProperty(key)){
//                 (objA as any)[key] = (objB as any)[key];
//             }
//         }
//         return <T1&T2>objA;
//     }

//     /**
//      * @param consumes string[] mime-types
//      * @return true: consumes contains 'multipart/form-data', false: otherwise
//      */
//     private canConsumeForm(consumes: string[]): boolean {
//         const form = 'multipart/form-data';
//         for (let consume of consumes) {
//             if (form === consume) {
//                 return true;
//             }
//         }
//         return false;
//     }

//     /**
//      * Creates a new BibTeX entry
//      * Creates a new BibTeX entry which is assigned a random unique ID. Clients are not allowed to specify a custom ID when using this method. Clients should use PUT instead in such a case.
//      * @param body BibTeX in JSON representation compliant with the BibTeX specifications. Malformed BibTeX entries with missing fields will not be accepted.
//      * @param subjectid Clients need to authenticate in order to create resources on the server
//      */
//     public createBibTeX(body: BibTeX, subjectid?: string, extraHttpRequestParams?: any): Observable<BibTeX> {
//         return this.createBibTeXWithHttpInfo(body, subjectid, extraHttpRequestParams)
//             .map((response: Response) => {
//                 if (response.status === 204) {
//                     return undefined;
//                 } else {
//                     return response.json() || {};
//                 }
//             });
//     }

//     /**
//      * Places a new BibTeX entry at a particular URI
//      * Creates a new BibTeX entry at the specified URI. If a BibTeX already exists at this URI,it will be replaced. If, instead, no BibTeX is stored under the specified URI, a new BibTeX entry will be created. Notice that authentication, authorization and accounting (quota) restrictions may apply.
//      * @param id ID of the BibTeX.
//      * @param body BibTeX in JSON
//      * @param subjectid Clients need to authenticate in order to create resources on the server
//      */
//     public createBibTeXGivenID(id: string, body: BibTeX, subjectid?: string, extraHttpRequestParams?: any): Observable<BibTeX> {
//         return this.createBibTeXGivenIDWithHttpInfo(id, body, subjectid, extraHttpRequestParams)
//             .map((response: Response) => {
//                 if (response.status === 204) {
//                     return undefined;
//                 } else {
//                     return response.json() || {};
//                 }
//             });
//     }

//     /**
//      * Deletes a particular BibTeX resource
//      * Deletes a BibTeX resource of a given ID. The method is idempondent, that is, it can be used more than once without triggering an exception/error. If the BibTeX does not exist, the method will return without errors. Authentication and authorization requirements apply, so clients that are not authenticated with a valid token or do not have sufficient priviledges will not be able to delete a BibTeX using this method.
//      * @param id ID of the BibTeX.
//      * @param subjectid Clients need to authenticate in order to create resources on the server
//      */
//     public deleteBibTeX(id: string, subjectid?: string, extraHttpRequestParams?: any): Observable<{}> {
//         return this.deleteBibTeXWithHttpInfo(id, subjectid, extraHttpRequestParams)
//             .map((response: Response) => {
//                 if (response.status === 204) {
//                     return undefined;
//                 } else {
//                     return response.json() || {};
//                 }
//             });
//     }

//     /**
//      * Returns BibTeX entry
//      * Finds and returns a BibTeX by ID
//      * @param id ID of the BibTeX
//      */
//     public getBibTeX(id: string, extraHttpRequestParams?: any): Observable<BibTeX> {
//         return this.getBibTeXWithHttpInfo(id, extraHttpRequestParams)
//             .map((response: Response) => {
//                 if (response.status === 204) {
//                     return undefined;
//                 } else {
//                     return response.json() || {};
//                 }
//             });
//     }

//     /**
//      * Finds all BibTeX entries
//      * Finds all BibTeX entries in the DB of Jaqpot and returns them in a list
//      * @param bibtype BibTeX type of entry
//      * @param creator Creator of the BibTeX entry
//      * @param query Generic query (e.g., Article title, journal name, etc)
//      * @param start start
//      * @param max max
//      */
//     public listBibTeXs(bibtype?: string, creator?: string, query?: string, start?: number, max?: number, extraHttpRequestParams?: any): Observable<Array<BibTeX>> {
//         return this.listBibTeXsWithHttpInfo(bibtype, creator, query, start, max, extraHttpRequestParams)
//             .map((response: Response) => {
//                 if (response.status === 204) {
//                     return undefined;
//                 } else {
//                     return response.json() || {};
//                 }
//             });
//     }

//     /**
//      * Modifies a particular BibTeX resource
//      * Modifies (applies a patch on) a BibTeX resource of a given ID. This implementation of PATCH follows the RFC 6902 proposed standard. See https://tools.ietf.org/rfc/rfc6902.txt for details.
//      * @param id ID of an existing BibTeX.
//      * @param body The patch in JSON according to the RFC 6902 specs
//      * @param subjectid Clients need to authenticate in order to create resources on the server
//      */
//     public modifyBibTeX(id: string, body: string, subjectid?: string, extraHttpRequestParams?: any): Observable<BibTeX> {
//         return this.modifyBibTeXWithHttpInfo(id, body, subjectid, extraHttpRequestParams)
//             .map((response: Response) => {
//                 if (response.status === 204) {
//                     return undefined;
//                 } else {
//                     return response.json() || {};
//                 }
//             });
//     }

//     /**
//      * Creates a new BibTeX entry
//      * Creates a new BibTeX entry which is assigned a random unique ID. Clients are not allowed to specify a custom ID when using this method. Clients should use PUT instead in such a case.
//      * @param body BibTeX in JSON representation compliant with the BibTeX specifications. Malformed BibTeX entries with missing fields will not be accepted.
//      * @param subjectid Clients need to authenticate in order to create resources on the server
//      */
//     public createBibTeXWithHttpInfo(body: BibTeX, subjectid?: string, extraHttpRequestParams?: any): Observable<Response> {
//         const path = this.basePath + '/bibtex';

//         let queryParameters = new URLSearchParams();
//         let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

//         // verify required parameter 'body' is not null or undefined
//         if (body === null || body === undefined) {
//             throw new Error('Required parameter body was null or undefined when calling createBibTeX.');
//         }
//         if (subjectid !== undefined && subjectid !== null) {
//             headers.set('subjectid', String(subjectid));
//         }

//         // to determine the Accept header
//         let produces: string[] = [
//             'application/json',
//             'text/uri-list'
//         ];

//         headers.set('Content-Type', 'application/json');

//         let requestOptions: RequestOptionsArgs = new RequestOptions({
//             method: RequestMethod.Post,
//             headers: headers,
//             body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
//             search: queryParameters,
//             withCredentials:this.configuration.withCredentials
//         });
//         // https://github.com/swagger-api/swagger-codegen/issues/4037
//         if (extraHttpRequestParams) {
//             requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
//         }

//         return this.http.request(path, requestOptions);
//     }

//     /**
//      * Places a new BibTeX entry at a particular URI
//      * Creates a new BibTeX entry at the specified URI. If a BibTeX already exists at this URI,it will be replaced. If, instead, no BibTeX is stored under the specified URI, a new BibTeX entry will be created. Notice that authentication, authorization and accounting (quota) restrictions may apply.
//      * @param id ID of the BibTeX.
//      * @param body BibTeX in JSON
//      * @param subjectid Clients need to authenticate in order to create resources on the server
//      */
//     public createBibTeXGivenIDWithHttpInfo(id: string, body: BibTeX, subjectid?: string, extraHttpRequestParams?: any): Observable<Response> {
//         const path = this.basePath + '/bibtex/${id}'
//                     .replace('${' + 'id' + '}', String(id));

//         let queryParameters = new URLSearchParams();
//         let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

//         // verify required parameter 'id' is not null or undefined
//         if (id === null || id === undefined) {
//             throw new Error('Required parameter id was null or undefined when calling createBibTeXGivenID.');
//         }
//         // verify required parameter 'body' is not null or undefined
//         if (body === null || body === undefined) {
//             throw new Error('Required parameter body was null or undefined when calling createBibTeXGivenID.');
//         }
//         if (subjectid !== undefined && subjectid !== null) {
//             headers.set('subjectid', String(subjectid));
//         }

//         // to determine the Accept header
//         let produces: string[] = [
//             'application/json',
//             'text/uri-list'
//         ];

//         headers.set('Content-Type', 'application/json');

//         let requestOptions: RequestOptionsArgs = new RequestOptions({
//             method: RequestMethod.Put,
//             headers: headers,
//             body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
//             search: queryParameters,
//             withCredentials:this.configuration.withCredentials
//         });
//         // https://github.com/swagger-api/swagger-codegen/issues/4037
//         if (extraHttpRequestParams) {
//             requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
//         }

//         return this.http.request(path, requestOptions);
//     }

//     /**
//      * Deletes a particular BibTeX resource
//      * Deletes a BibTeX resource of a given ID. The method is idempondent, that is, it can be used more than once without triggering an exception/error. If the BibTeX does not exist, the method will return without errors. Authentication and authorization requirements apply, so clients that are not authenticated with a valid token or do not have sufficient priviledges will not be able to delete a BibTeX using this method.
//      * @param id ID of the BibTeX.
//      * @param subjectid Clients need to authenticate in order to create resources on the server
//      */
//     public deleteBibTeXWithHttpInfo(id: string, subjectid?: string, extraHttpRequestParams?: any): Observable<Response> {
//         const path = this.basePath + '/bibtex/${id}'
//                     .replace('${' + 'id' + '}', String(id));

//         let queryParameters = new URLSearchParams();
//         let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

//         // verify required parameter 'id' is not null or undefined
//         if (id === null || id === undefined) {
//             throw new Error('Required parameter id was null or undefined when calling deleteBibTeX.');
//         }
//         if (subjectid !== undefined && subjectid !== null) {
//             headers.set('subjectid', String(subjectid));
//         }

//         // to determine the Accept header
//         let produces: string[] = [
//             'application/json',
//             'text/uri-list'
//         ];

//         let requestOptions: RequestOptionsArgs = new RequestOptions({
//             method: RequestMethod.Delete,
//             headers: headers,
//             search: queryParameters,
//             withCredentials:this.configuration.withCredentials
//         });
//         // https://github.com/swagger-api/swagger-codegen/issues/4037
//         if (extraHttpRequestParams) {
//             requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
//         }

//         return this.http.request(path, requestOptions);
//     }

//     /**
//      * Returns BibTeX entry
//      * Finds and returns a BibTeX by ID
//      * @param id ID of the BibTeX
//      */
//     public getBibTeXWithHttpInfo(id: string, extraHttpRequestParams?: any): Observable<Response> {
//         const path = this.basePath + '/bibtex/${id}'
//                     .replace('${' + 'id' + '}', String(id));

//         let queryParameters = new URLSearchParams();
//         let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

//         // verify required parameter 'id' is not null or undefined
//         if (id === null || id === undefined) {
//             throw new Error('Required parameter id was null or undefined when calling getBibTeX.');
//         }

//         // to determine the Accept header
//         let produces: string[] = [
//             'application/json',
//             'text/uri-list'
//         ];

//         let requestOptions: RequestOptionsArgs = new RequestOptions({
//             method: RequestMethod.Get,
//             headers: headers,
//             search: queryParameters,
//             withCredentials:this.configuration.withCredentials
//         });
//         // https://github.com/swagger-api/swagger-codegen/issues/4037
//         if (extraHttpRequestParams) {
//             requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
//         }

//         return this.http.request(path, requestOptions);
//     }

//     /**
//      * Finds all BibTeX entries
//      * Finds all BibTeX entries in the DB of Jaqpot and returns them in a list
//      * @param bibtype BibTeX type of entry
//      * @param creator Creator of the BibTeX entry
//      * @param query Generic query (e.g., Article title, journal name, etc)
//      * @param start start
//      * @param max max
//      */
//     public listBibTeXsWithHttpInfo(bibtype?: string, creator?: string, query?: string, start?: number, max?: number, extraHttpRequestParams?: any): Observable<Response> {
//         const path = this.basePath + '/bibtex';

//         let queryParameters = new URLSearchParams();
//         let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

//         if (bibtype !== undefined) {
//             queryParameters.set('bibtype', <any>bibtype);
//         }

//         if (creator !== undefined) {
//             queryParameters.set('creator', <any>creator);
//         }

//         if (query !== undefined) {
//             queryParameters.set('query', <any>query);
//         }

//         if (start !== undefined) {
//             queryParameters.set('start', <any>start);
//         }

//         if (max !== undefined) {
//             queryParameters.set('max', <any>max);
//         }

//         // to determine the Accept header
//         let produces: string[] = [
//             'application/json',
//             'text/uri-list'
//         ];

//         let requestOptions: RequestOptionsArgs = new RequestOptions({
//             method: RequestMethod.Get,
//             headers: headers,
//             search: queryParameters,
//             withCredentials:this.configuration.withCredentials
//         });
//         // https://github.com/swagger-api/swagger-codegen/issues/4037
//         if (extraHttpRequestParams) {
//             requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
//         }

//         return this.http.request(path, requestOptions);
//     }

//     /**
//      * Modifies a particular BibTeX resource
//      * Modifies (applies a patch on) a BibTeX resource of a given ID. This implementation of PATCH follows the RFC 6902 proposed standard. See https://tools.ietf.org/rfc/rfc6902.txt for details.
//      * @param id ID of an existing BibTeX.
//      * @param body The patch in JSON according to the RFC 6902 specs
//      * @param subjectid Clients need to authenticate in order to create resources on the server
//      */
//     public modifyBibTeXWithHttpInfo(id: string, body: string, subjectid?: string, extraHttpRequestParams?: any): Observable<Response> {
//         const path = this.basePath + '/bibtex/${id}'
//                     .replace('${' + 'id' + '}', String(id));

//         let queryParameters = new URLSearchParams();
//         let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

//         // verify required parameter 'id' is not null or undefined
//         if (id === null || id === undefined) {
//             throw new Error('Required parameter id was null or undefined when calling modifyBibTeX.');
//         }
//         // verify required parameter 'body' is not null or undefined
//         if (body === null || body === undefined) {
//             throw new Error('Required parameter body was null or undefined when calling modifyBibTeX.');
//         }
//         if (subjectid !== undefined && subjectid !== null) {
//             headers.set('subjectid', String(subjectid));
//         }

//         // to determine the Accept header
//         let produces: string[] = [
//             'application/json',
//             'text/uri-list'
//         ];

//         headers.set('Content-Type', 'application/json');

//         let requestOptions: RequestOptionsArgs = new RequestOptions({
//             method: RequestMethod.Patch,
//             headers: headers,
//             body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
//             search: queryParameters,
//             withCredentials:this.configuration.withCredentials
//         });
//         // https://github.com/swagger-api/swagger-codegen/issues/4037
//         if (extraHttpRequestParams) {
//             requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
//         }

//         return this.http.request(path, requestOptions);
//     }

// }
