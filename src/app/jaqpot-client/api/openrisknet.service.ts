// /**
//  * Jaqpot API
//  * Jaqpot v4 (Quattro) is the 4th version of a YAQP, a RESTful web service which can be used to train machine learning models and use them to obtain toxicological predictions for given chemical compounds or engineered nano materials. The project is written in Java8 and JEE7.
//  *
//  * OpenAPI spec version: 4.0.3
//  * Contact: hampos@me.com
//  *
//  * NOTE: This class is auto generated by the swagger code generator program.
//  * https://github.com/swagger-api/swagger-codegen.git
//  * Do not edit the class manually.
//  */

// /* tslint:disable:no-unused-variable member-ordering */

// import { Inject, Injectable, Optional }                      from '@angular/core';
// import { Http, Headers, URLSearchParams }                    from '@angular/http';
// import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
// import { Response, ResponseContentType }                     from '@angular/http';

// import { Observable }                                        from 'rxjs/Observable';
// import '../rxjs-operators';

// import { Task } from '../model/task';

// import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
// import { Configuration }                                     from '../configuration';


// @Injectable()
// export class OpenrisknetService {

//     protected basePath = 'http://dev.jaqpot.org:8081/jaqpot/services';
//     public defaultHeaders: Headers = new Headers();
//     public configuration: Configuration = new Configuration();

//     constructor(protected http: Http, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
//         if (basePath) {
//             this.basePath = basePath;
//         }
//         if (configuration) {
//             this.configuration = configuration;
// 			this.basePath = basePath || configuration.basePath || this.basePath;
//         }
//     }

//     /**
//      *
//      * Extends object by coping non-existing properties.
//      * @param objA object to be extended
//      * @param objB source object
//      */
//     private extendObj<T1,T2>(objA: T1, objB: T2) {
//         for(let key in objB){
//             if(objB.hasOwnProperty(key)){
//                 (objA as any)[key] = (objB as any)[key];
//             }
//         }
//         return <T1&T2>objA;
//     }

//     /**
//      * @param consumes string[] mime-types
//      * @return true: consumes contains 'multipart/form-data', false: otherwise
//      */
//     private canConsumeForm(consumes: string[]): boolean {
//         const form = 'multipart/form-data';
//         for (let consume of consumes) {
//             if (form === consume) {
//                 return true;
//             }
//         }
//         return false;
//     }

//     /**
//      * Creates Dataset By SMILES document
//      * Calculates descriptors from SMILES document, returns Dataset
//      * @param file xls[m,x] file
//      * @param title Title of dataset
//      * @param description Description of dataset
//      * @param algorithmUri Algorithm URI
//      * @param subjectid
//      * @param parameters Parameters for algorithm
//      */
//     public uploadFile(file: Blob, title: string, description: string, algorithmUri: string, subjectid?: string, parameters?: string, extraHttpRequestParams?: any): Observable<Task> {
//         return this.uploadFileWithHttpInfo(file, title, description, algorithmUri, subjectid, parameters, extraHttpRequestParams)
//             .map((response: Response) => {
//                 if (response.status === 204) {
//                     return undefined;
//                 } else {
//                     return response.json() || {};
//                 }
//             });
//     }


//     /**
//      * Creates Dataset By SMILES document
//      * Calculates descriptors from SMILES document, returns Dataset
//      * @param file xls[m,x] file
//      * @param title Title of dataset
//      * @param description Description of dataset
//      * @param algorithmUri Algorithm URI
//      * @param subjectid
//      * @param parameters Parameters for algorithm
//      */
//     public uploadFileWithHttpInfo(file: Blob, title: string, description: string, algorithmUri: string, subjectid?: string, parameters?: string, extraHttpRequestParams?: any): Observable<Response> {
//         const path = this.basePath + '/openrisknet/upload';

//         let queryParameters = new URLSearchParams();
//         let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

//         // verify required parameter 'file' is not null or undefined
//         if (file === null || file === undefined) {
//             throw new Error('Required parameter file was null or undefined when calling uploadFile.');
//         }
//         // verify required parameter 'title' is not null or undefined
//         if (title === null || title === undefined) {
//             throw new Error('Required parameter title was null or undefined when calling uploadFile.');
//         }
//         // verify required parameter 'description' is not null or undefined
//         if (description === null || description === undefined) {
//             throw new Error('Required parameter description was null or undefined when calling uploadFile.');
//         }
//         // verify required parameter 'algorithmUri' is not null or undefined
//         if (algorithmUri === null || algorithmUri === undefined) {
//             throw new Error('Required parameter algorithmUri was null or undefined when calling uploadFile.');
//         }
//         if (subjectid !== undefined && subjectid !== null) {
//             headers.set('subjectid', String(subjectid));
//         }

//         // to determine the Content-Type header
//         let consumes: string[] = [
//             'multipart/form-data'
//         ];
//         let canConsumeForm = this.canConsumeForm(consumes);
//         let useForm = false;
//         useForm = canConsumeForm;
//         let formParams = new (useForm ? FormData : URLSearchParams as any)() as {
//           set(param: string, value: any): void;
//         };

//         // to determine the Accept header
//         let produces: string[] = [
//         ];


//         if (file !== undefined) {
//             formParams.set('file', <any>file);
//         }

//         if (title !== undefined) {
//             formParams.set('title', <any>title);
//         }

//         if (description !== undefined) {
//             formParams.set('description', <any>description);
//         }

//         if (algorithmUri !== undefined) {
//             formParams.set('algorithm-uri', <any>algorithmUri);
//         }

//         if (parameters !== undefined) {
//             formParams.set('parameters', <any>parameters);
//         }

//         let requestOptions: RequestOptionsArgs = new RequestOptions({
//             method: RequestMethod.Post,
//             headers: headers,
//             body: formParams.toString(),
//             search: queryParameters,
//             withCredentials:this.configuration.withCredentials
//         });
//         // https://github.com/swagger-api/swagger-codegen/issues/4037
//         if (extraHttpRequestParams) {
//             requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
//         }

//         return this.http.request(path, requestOptions);
//     }

// }
